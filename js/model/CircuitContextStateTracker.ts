// Copyright 2025, University of Colorado Boulder

/**
 * Captures circuit state before topological/value changes and emits combined accessible summaries.
 *
 * TODO: This file was autogenerated and has not yet been reviewed, see https://github.com/phetsims/circuit-construction-kit-common/issues/1039
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import Emitter from '../../../axon/js/Emitter.js';
import type TEmitter from '../../../axon/js/TEmitter.js';
import { clamp } from '../../../dot/js/util/clamp.js';
import { toFixed } from '../../../dot/js/util/toFixed.js';
import circuitConstructionKitCommon from '../circuitConstructionKitCommon.js';
import CircuitConstructionKitCommonFluent from '../CircuitConstructionKitCommonFluent.js';
import CircuitDescriptionUtils from '../CircuitDescriptionUtils.js';
import Battery from './Battery.js';
import type Circuit from './Circuit.js';
import CircuitElement from './CircuitElement.js';
import FixedCircuitElement from './FixedCircuitElement.js';
import LightBulb from './LightBulb.js';
import Resistor from './Resistor.js';
import Vertex from './Vertex.js';

type LightBulbAnnouncementState = 'off' | 'dim' | 'steady' | 'bright';

type CircuitElementAnnouncementState = {
  currentMagnitude: number;
  resistance: number | null;
  voltage: number | null;
  brightnessState: LightBulbAnnouncementState | null;
};

type VertexAnnouncementState = {
  connectionCount: number;
};

type PendingContextEvent =
  | {
  type: 'vertices-joined';
  vertex: Vertex;
  wasInExistingGroup: boolean; // True if vertex was already in a multi-element group before merge
  groupIndex: number | null; // Group index if joining an existing group
}
  | {
  type: 'vertex-split';
  vertexLabel: string;
  createdVertexCount: number;
}
  | {
  type: 'element-removed';
  elementName: string;
};

const CURRENT_PRESENT_THRESHOLD = 1E-4;
const CURRENT_EQUALITY_TOLERANCE = 1E-3;
const LIGHT_BULB_BRIGHTNESS_MULTIPLIER = 0.35;
const LIGHT_BULB_MAXIMUM_POWER = 2000;
const LIGHT_BULB_OFF_THRESHOLD = 0.05;
const LIGHT_BULB_DIM_THRESHOLD = 0.4;
const LIGHT_BULB_STEADY_THRESHOLD = 0.75;

export default class CircuitContextStateTracker {
  public readonly contextAnnouncementEmitter: TEmitter<[ string ]>;
  private circuitElementAnnouncementStates: Map<CircuitElement, CircuitElementAnnouncementState> | null;
  private vertexAnnouncementStates: Map<Vertex, VertexAnnouncementState> | null;
  private pendingContextEvents: PendingContextEvent[];
  private readonly circuitElementStateCaptureDisposers: Map<CircuitElement, () => void>;

  public constructor( private readonly circuit: Circuit ) {
    this.contextAnnouncementEmitter = new Emitter( {
      parameters: [ {
        name: 'announcement',
        valueType: 'string'
      } ]
    } );
    this.circuitElementAnnouncementStates = null;
    this.vertexAnnouncementStates = null;
    this.pendingContextEvents = [];
    this.circuitElementStateCaptureDisposers = new Map();
  }

  public handleElementAdded( circuitElement: CircuitElement ): void {
    this.registerCircuitElement( circuitElement );
  }

  public handleElementRemoved( circuitElement: CircuitElement ): void {
    this.unregisterCircuitElement( circuitElement );
    this.captureCircuitContextState();
    this.pendingContextEvents.push( {
      type: 'element-removed',
      elementName: this.getElementDisplayName( circuitElement )
    } );
  }

  public handleVertexMerged( vertex: Vertex ): void {
    this.captureCircuitContextState();

    // Check if we're joining an existing group (more than 2 elements means it was already a group)
    const groups = this.circuit.getGroups();
    const currentGroup = groups.find( g => g.vertices.includes( vertex ) );
    const groupSize = currentGroup ? currentGroup.circuitElements.length : 0;

    // If group has more than 2 elements, we joined an existing group
    const wasInExistingGroup = groupSize > 2;

    // Get the group index if joining an existing group
    let groupIndex: number | null = null;
    if ( wasInExistingGroup && currentGroup ) {
      const multiElementGroups = groups.filter( g => g.circuitElements.length > 1 );
      groupIndex = multiElementGroups.indexOf( currentGroup ) + 1;
    }

    this.pendingContextEvents.push( {
      type: 'vertices-joined',
      vertex: vertex,
      wasInExistingGroup: wasInExistingGroup,
      groupIndex: groupIndex
    } );
  }

  public handleVertexSplit( vertex: Vertex, createdVertexCount: number ): void {
    if ( createdVertexCount <= 1 ) {
      return;
    }
    this.captureCircuitContextState();
    this.pendingContextEvents.push( {
      type: 'vertex-split',
      vertexLabel: this.getVertexLabel( vertex ),
      createdVertexCount: createdVertexCount
    } );
  }

  public handleStepCompleted(): void {
    this.processPendingContextAnnouncements();
  }

  private registerCircuitElement( circuitElement: CircuitElement ): void {
    // NOTE: Resistance and voltage change announcements are now handled by CircuitContextResponses
    // via createContextResponseAlert on the sliders in CircuitElementEditContainerNode.
    // This method is kept for potential future use but currently does not attach any listeners.
    const disposers: Array<() => void> = [];

    if ( disposers.length > 0 ) {
      this.circuitElementStateCaptureDisposers.set( circuitElement, () => disposers.forEach( disposer => disposer() ) );
      circuitElement.disposeEmitterCircuitElement.addListener( () => this.unregisterCircuitElement( circuitElement ) );
    }
  }

  private unregisterCircuitElement( circuitElement: CircuitElement ): void {
    const disposer = this.circuitElementStateCaptureDisposers.get( circuitElement );
    if ( disposer ) {
      disposer();
      this.circuitElementStateCaptureDisposers.delete( circuitElement );
    }
  }

  private captureCircuitContextState(): boolean {
    if ( this.circuitElementAnnouncementStates ) {
      return false;
    }
    this.circuitElementAnnouncementStates = new Map();
    this.circuit.circuitElements.forEach( circuitElement => {
      this.circuitElementAnnouncementStates!.set( circuitElement, this.createCircuitElementAnnouncementState( circuitElement ) );
    } );

    this.vertexAnnouncementStates = new Map();
    for ( let i = 0; i < this.circuit.vertexGroup.count; i++ ) {
      const vertex = this.circuit.vertexGroup.getElement( i );
      this.vertexAnnouncementStates.set( vertex, this.createVertexAnnouncementState( vertex ) );
    }
    return true;
  }

  private createCircuitElementAnnouncementState( circuitElement: CircuitElement ): CircuitElementAnnouncementState {
    const isResistor = circuitElement instanceof Resistor;
    const isLightBulb = circuitElement instanceof LightBulb;
    return {
      currentMagnitude: Math.abs( circuitElement.currentProperty.value ),
      resistance: isResistor || isLightBulb ? ( circuitElement ).resistanceProperty.value : null,
      voltage: circuitElement instanceof Battery ? circuitElement.voltageProperty.value : null,
      brightnessState: isLightBulb ? this.getLightBulbAnnouncementState( circuitElement ) : null
    };
  }

  private createVertexAnnouncementState( vertex: Vertex ): VertexAnnouncementState {
    return {
      connectionCount: this.circuit.countCircuitElements( vertex )
    };
  }

  private collectCircuitElementAnnouncementStates(): Map<CircuitElement, CircuitElementAnnouncementState> {
    const map = new Map<CircuitElement, CircuitElementAnnouncementState>();
    this.circuit.circuitElements.forEach( circuitElement => {
      map.set( circuitElement, this.createCircuitElementAnnouncementState( circuitElement ) );
    } );
    return map;
  }

  private collectVertexAnnouncementStates(): Map<Vertex, VertexAnnouncementState> {
    const map = new Map<Vertex, VertexAnnouncementState>();
    for ( let i = 0; i < this.circuit.vertexGroup.count; i++ ) {
      const vertex = this.circuit.vertexGroup.getElement( i );
      map.set( vertex, this.createVertexAnnouncementState( vertex ) );
    }
    return map;
  }

  private getLightBulbAnnouncementState( lightBulb: LightBulb ): LightBulbAnnouncementState {
    const brightness = this.computeLightBulbBrightness( lightBulb );
    if ( brightness <= LIGHT_BULB_OFF_THRESHOLD ) {
      return 'off';
    }
    if ( brightness <= LIGHT_BULB_DIM_THRESHOLD ) {
      return 'dim';
    }
    if ( brightness <= LIGHT_BULB_STEADY_THRESHOLD ) {
      return 'steady';
    }
    return 'bright';
  }

  private computeLightBulbBrightness( lightBulb: LightBulb ): number {
    const current = lightBulb.currentProperty.value;
    const resistance = lightBulb.resistanceProperty.value;
    const power = Math.abs( current * current * resistance );
    const numerator = Math.log( 1 + power * LIGHT_BULB_BRIGHTNESS_MULTIPLIER );
    const denominator = Math.log( 1 + LIGHT_BULB_MAXIMUM_POWER * LIGHT_BULB_BRIGHTNESS_MULTIPLIER );
    return clamp( denominator === 0 ? 0 : numerator / denominator, 0, 1 );
  }

  private processPendingContextAnnouncements(): void {
    if ( !this.circuitElementAnnouncementStates && !this.vertexAnnouncementStates && this.pendingContextEvents.length === 0 ) {
      return;
    }

    const sentences: string[] = [];
    const currentElementStates = this.circuitElementAnnouncementStates ? this.collectCircuitElementAnnouncementStates() : null;

    this.pendingContextEvents.forEach( event => {
      if ( event.type === 'vertices-joined' ) {
        const connectedComponents = this.getConnectedComponentDescriptions( event.vertex );
        if ( connectedComponents.length > 0 ) {
          sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.connectedComponents.format( {
            components: connectedComponents.join( ', ' ),
            inGroup: event.wasInExistingGroup ? 'true' : 'false',
            groupIndex: event.groupIndex || 0
          } ) );
        }
      }
      else if ( event.type === 'vertex-split' ) {
        sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.junctionSplit.format( {
          junctionName: event.vertexLabel,
          connectionCount: event.createdVertexCount
        } ) );
      }
      else {
        sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.componentRemoved.format( {
          componentName: event.elementName
        } ) );
      }
    } );

    if ( this.circuitElementAnnouncementStates && currentElementStates ) {
      this.circuitElementAnnouncementStates.forEach( ( previousState, circuitElement ) => {
        const currentState = currentElementStates.get( circuitElement );
        if ( !currentState ) {
          return;
        }

        if ( previousState.brightnessState && currentState.brightnessState &&
             previousState.brightnessState !== currentState.brightnessState ) {
          sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.lightBulbState.format( {
            componentName: this.getElementDisplayName( circuitElement ),
            state: currentState.brightnessState
          } ) );
        }

        if ( previousState.resistance !== null && currentState.resistance !== null &&
             !this.areValuesClose( previousState.resistance, currentState.resistance ) ) {
          const type = circuitElement instanceof LightBulb ? 'lightBulb' : 'resistor';
          sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.componentValueChange.format( {
            componentName: this.getElementDisplayName( circuitElement ),
            type: type,
            oldValue: this.formatValue( previousState.resistance, this.getDisplayDecimalPlaces( circuitElement ) ),
            newValue: this.formatValue( currentState.resistance, this.getDisplayDecimalPlaces( circuitElement ) )
          } ) );
        }

        if ( previousState.voltage !== null && currentState.voltage !== null &&
             !this.areValuesClose( previousState.voltage, currentState.voltage ) ) {
          sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.componentValueChange.format( {
            componentName: this.getElementDisplayName( circuitElement ),
            type: 'battery',
            oldValue: this.formatValue( previousState.voltage, this.getDisplayDecimalPlaces( circuitElement ) ),
            newValue: this.formatValue( currentState.voltage, this.getDisplayDecimalPlaces( circuitElement ) )
          } ) );
        }
      } );
    }

    const previousCurrentMagnitudes = this.circuitElementAnnouncementStates ?
                                      Array.from( this.circuitElementAnnouncementStates.values() ).map( state => state.currentMagnitude ) :
      [];
    const currentCurrentMagnitudes = currentElementStates ?
                                     Array.from( currentElementStates.values() ).map( state => state.currentMagnitude ) :
      [];
    this.appendCurrentFlowSentence( previousCurrentMagnitudes, currentCurrentMagnitudes, sentences );

    if ( sentences.length > 0 ) {
      this.contextAnnouncementEmitter.emit( sentences.join( ' ' ) );
    }

    this.clearPendingContextAnnouncements();
  }

  public clearPendingContextAnnouncements(): void {
    this.circuitElementAnnouncementStates = null;
    this.vertexAnnouncementStates = null;
    this.pendingContextEvents.length = 0;
  }

  /**
   * Returns rich descriptions for each circuit element connected to the vertex.
   * Each description includes the element's brief name (e.g., "Wire 1") and terminal info
   * (e.g., "Negative Terminal of Battery 2").
   */
  private getConnectedComponentDescriptions( vertex: Vertex ): string[] {
    const connectedElements = this.circuit.getNeighborCircuitElements( vertex );
    const descriptions: string[] = [];

    connectedElements.forEach( element => {
      // Get the position of this element among elements of the same type
      const position = CircuitDescriptionUtils.getElementPosition( this.circuit, element );
      const briefName = CircuitDescriptionUtils.formatCircuitElementBriefName( element, position );

      // Get the terminal description for this vertex connection
      const terminalDescription = CircuitDescriptionUtils.formatTerminalDescription( vertex, element, briefName );

      descriptions.push( terminalDescription );
    } );

    return descriptions;
  }

  private getElementDisplayName( circuitElement: CircuitElement ): string {
    const label = circuitElement.labelStringProperty.value.trim();
    if ( label.length > 0 ) {
      return label;
    }
    // Use CircuitDescriptionUtils to get the proper type label (handles household items correctly)
    const position = CircuitDescriptionUtils.getElementPosition( this.circuit, circuitElement );
    return CircuitDescriptionUtils.formatCircuitElementBriefName( circuitElement, position );
  }

  private getVertexLabel( vertex: Vertex ): string {
    const label = vertex.labelStringProperty.value.trim();
    if ( label.length > 0 ) {
      return label;
    }
    return CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.junctionDefaultLabel.format( {
      index: vertex.index + 1
    } );
  }

  private formatValue( value: number, decimalPlaces: number ): string {
    return toFixed( value, decimalPlaces );
  }

  private formatCurrent( magnitude: number ): string {
    return toFixed( magnitude, 2 );
  }

  private areValuesClose( a: number, b: number ): boolean {
    return Math.abs( a - b ) < 1E-6;
  }

  private getDisplayDecimalPlaces( circuitElement: CircuitElement ): number {
    return circuitElement instanceof FixedCircuitElement ? circuitElement.numberOfDecimalPlaces : 2;
  }

  private getUniqueCurrentMagnitudes( magnitudes: number[] ): number[] {
    const sorted = magnitudes.slice().sort( ( a, b ) => a - b );
    const unique: number[] = [];
    sorted.forEach( value => {
      const isDuplicate = unique.some( existing => Math.abs( existing - value ) < CURRENT_EQUALITY_TOLERANCE );
      if ( !isDuplicate ) {
        unique.push( value );
      }
    } );
    return unique;
  }

  private haveCurrentMagnitudesChanged( previous: number[], current: number[] ): boolean {
    if ( previous.length !== current.length ) {
      return true;
    }
    const sortedPrevious = previous.slice().sort( ( a, b ) => a - b );
    const sortedCurrent = current.slice().sort( ( a, b ) => a - b );
    for ( let i = 0; i < sortedPrevious.length; i++ ) {
      if ( Math.abs( sortedPrevious[ i ] - sortedCurrent[ i ] ) > CURRENT_EQUALITY_TOLERANCE ) {
        return true;
      }
    }
    return false;
  }

  private appendCurrentFlowSentence( previousMagnitudes: number[], currentMagnitudes: number[], sentences: string[] ): void {
    const previousFlowing = previousMagnitudes.filter( magnitude => magnitude > CURRENT_PRESENT_THRESHOLD );
    const currentFlowing = currentMagnitudes.filter( magnitude => magnitude > CURRENT_PRESENT_THRESHOLD );
    const hadFlowBefore = previousFlowing.length > 0;
    const hasFlowNow = currentFlowing.length > 0;

    if ( hasFlowNow ) {
      const flowsChanged = !hadFlowBefore || this.haveCurrentMagnitudesChanged( previousFlowing, currentFlowing );
      if ( flowsChanged ) {
        const uniqueCurrents = this.getUniqueCurrentMagnitudes( currentFlowing );
        if ( uniqueCurrents.length <= 1 ) {
          const magnitude = uniqueCurrents.length === 1 ? uniqueCurrents[ 0 ] : currentFlowing[ 0 ];
          sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.currentChangedSingle.format( {
            current: this.formatCurrent( magnitude )
          } ) );
        }
        else {
          sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.currentMultipleStringProperty.value );
        }
      }
    }
    else if ( hadFlowBefore ) {
      sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.currentStoppedStringProperty.value );
    }
  }
}

circuitConstructionKitCommon.register( 'CircuitContextStateTracker', CircuitContextStateTracker );
