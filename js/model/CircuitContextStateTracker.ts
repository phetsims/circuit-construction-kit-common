// Copyright 2025, University of Colorado Boulder

/**
 * Captures circuit state before topological/value changes and emits combined accessible summaries.
 *
 * TODO: This file was autogenerated and has not yet been reviewed, see https://github.com/phetsims/circuit-construction-kit-common/issues/1039
 *
 * @author Sam Reid (PhET Interactive Simulations)
 */

import Emitter from '../../../axon/js/Emitter.js';
import type TEmitter from '../../../axon/js/TEmitter.js';
import Utils from '../../../dot/js/Utils.js';
import circuitConstructionKitCommon from '../circuitConstructionKitCommon.js';
import CircuitConstructionKitCommonFluent from '../CircuitConstructionKitCommonFluent.js';
import CircuitConstructionKitCommonStrings from '../CircuitConstructionKitCommonStrings.js';
import Battery from './Battery.js';
import type Circuit from './Circuit.js';
import CircuitElement from './CircuitElement.js';
import FixedCircuitElement from './FixedCircuitElement.js';
import LightBulb from './LightBulb.js';
import Resistor from './Resistor.js';
import Vertex from './Vertex.js';

type LightBulbAnnouncementState = 'off' | 'dim' | 'steady' | 'bright';

type CircuitElementAnnouncementState = {
  currentMagnitude: number;
  resistance: number | null;
  voltage: number | null;
  brightnessState: LightBulbAnnouncementState | null;
};

type VertexAnnouncementState = {
  connectionCount: number;
};

type PendingContextEvent =
  | {
  type: 'vertices-joined';
  vertex: Vertex;
}
  | {
  type: 'vertex-split';
  vertexLabel: string;
  createdVertexCount: number;
}
  | {
  type: 'element-removed';
  elementName: string;
};

const CURRENT_PRESENT_THRESHOLD = 1E-4;
const CURRENT_EQUALITY_TOLERANCE = 1E-3;
const LIGHT_BULB_BRIGHTNESS_MULTIPLIER = 0.35;
const LIGHT_BULB_MAXIMUM_POWER = 2000;
const LIGHT_BULB_OFF_THRESHOLD = 0.05;
const LIGHT_BULB_DIM_THRESHOLD = 0.4;
const LIGHT_BULB_STEADY_THRESHOLD = 0.75;

export default class CircuitContextStateTracker {
  public readonly contextAnnouncementEmitter: TEmitter<[ string ]>;
  private circuitElementAnnouncementStates: Map<CircuitElement, CircuitElementAnnouncementState> | null;
  private vertexAnnouncementStates: Map<Vertex, VertexAnnouncementState> | null;
  private pendingContextEvents: PendingContextEvent[];
  private readonly circuitElementStateCaptureDisposers: Map<CircuitElement, () => void>;

  public constructor( private readonly circuit: Circuit ) {
    this.contextAnnouncementEmitter = new Emitter( {
      parameters: [ {
        name: 'announcement',
        valueType: 'string'
      } ]
    } );
    this.circuitElementAnnouncementStates = null;
    this.vertexAnnouncementStates = null;
    this.pendingContextEvents = [];
    this.circuitElementStateCaptureDisposers = new Map();
  }

  public handleElementAdded( circuitElement: CircuitElement ): void {
    this.registerCircuitElement( circuitElement );
  }

  public handleElementRemoved( circuitElement: CircuitElement ): void {
    this.unregisterCircuitElement( circuitElement );
    this.captureCircuitContextState();
    this.pendingContextEvents.push( {
      type: 'element-removed',
      elementName: this.getElementDisplayName( circuitElement )
    } );
  }

  public handleVertexMerged( vertex: Vertex ): void {
    this.captureCircuitContextState();
    this.pendingContextEvents.push( {
      type: 'vertices-joined',
      vertex: vertex
    } );
  }

  public handleVertexSplit( vertex: Vertex, createdVertexCount: number ): void {
    if ( createdVertexCount <= 1 ) {
      return;
    }
    this.captureCircuitContextState();
    this.pendingContextEvents.push( {
      type: 'vertex-split',
      vertexLabel: this.getVertexLabel( vertex ),
      createdVertexCount: createdVertexCount
    } );
  }

  public handleStepCompleted(): void {
    this.processPendingContextAnnouncements();
  }

  private registerCircuitElement( circuitElement: CircuitElement ): void {
    const disposers: Array<() => void> = [];

    const handleBatteryChange = ( newValue: number, oldValue: number | null ) => {
      if ( oldValue === null || oldValue === undefined || newValue === oldValue ) {
        return;
      }
      const snapshotCreated = this.captureCircuitContextState();
      if ( snapshotCreated ) {
        const state = this.circuitElementAnnouncementStates?.get( circuitElement );
        if ( state ) {
          state.voltage = oldValue;
        }
      }
    };

    const handleResistanceChange = ( newValue: number, oldValue: number | null ) => {
      if ( oldValue === null || oldValue === undefined || newValue === oldValue ) {
        return;
      }
      const snapshotCreated = this.captureCircuitContextState();
      if ( snapshotCreated ) {
        const state = this.circuitElementAnnouncementStates?.get( circuitElement );
        if ( state ) {
          state.resistance = oldValue;
        }
      }
    };

    if ( circuitElement instanceof Battery ) {
      circuitElement.voltageProperty.lazyLink( handleBatteryChange );
      disposers.push( () => circuitElement.voltageProperty.unlink( handleBatteryChange ) );
    }
    if ( circuitElement instanceof Resistor ) {
      circuitElement.resistanceProperty.lazyLink( handleResistanceChange );
      disposers.push( () => circuitElement.resistanceProperty.unlink( handleResistanceChange ) );
    }
    if ( circuitElement instanceof LightBulb ) {
      circuitElement.resistanceProperty.lazyLink( handleResistanceChange );
      disposers.push( () => circuitElement.resistanceProperty.unlink( handleResistanceChange ) );
    }

    if ( disposers.length > 0 ) {
      this.circuitElementStateCaptureDisposers.set( circuitElement, () => disposers.forEach( disposer => disposer() ) );
      circuitElement.disposeEmitterCircuitElement.addListener( () => this.unregisterCircuitElement( circuitElement ) );
    }
  }

  private unregisterCircuitElement( circuitElement: CircuitElement ): void {
    const disposer = this.circuitElementStateCaptureDisposers.get( circuitElement );
    if ( disposer ) {
      disposer();
      this.circuitElementStateCaptureDisposers.delete( circuitElement );
    }
  }

  private captureCircuitContextState(): boolean {
    if ( this.circuitElementAnnouncementStates ) {
      return false;
    }
    this.circuitElementAnnouncementStates = new Map();
    this.circuit.circuitElements.forEach( circuitElement => {
      this.circuitElementAnnouncementStates!.set( circuitElement, this.createCircuitElementAnnouncementState( circuitElement ) );
    } );

    this.vertexAnnouncementStates = new Map();
    for ( let i = 0; i < this.circuit.vertexGroup.count; i++ ) {
      const vertex = this.circuit.vertexGroup.getElement( i );
      this.vertexAnnouncementStates.set( vertex, this.createVertexAnnouncementState( vertex ) );
    }
    return true;
  }

  private createCircuitElementAnnouncementState( circuitElement: CircuitElement ): CircuitElementAnnouncementState {
    const isResistor = circuitElement instanceof Resistor;
    const isLightBulb = circuitElement instanceof LightBulb;
    return {
      currentMagnitude: Math.abs( circuitElement.currentProperty.value ),
      resistance: isResistor || isLightBulb ? ( circuitElement ).resistanceProperty.value : null,
      voltage: circuitElement instanceof Battery ? circuitElement.voltageProperty.value : null,
      brightnessState: isLightBulb ? this.getLightBulbAnnouncementState( circuitElement ) : null
    };
  }

  private createVertexAnnouncementState( vertex: Vertex ): VertexAnnouncementState {
    return {
      connectionCount: this.circuit.countCircuitElements( vertex )
    };
  }

  private collectCircuitElementAnnouncementStates(): Map<CircuitElement, CircuitElementAnnouncementState> {
    const map = new Map<CircuitElement, CircuitElementAnnouncementState>();
    this.circuit.circuitElements.forEach( circuitElement => {
      map.set( circuitElement, this.createCircuitElementAnnouncementState( circuitElement ) );
    } );
    return map;
  }

  private collectVertexAnnouncementStates(): Map<Vertex, VertexAnnouncementState> {
    const map = new Map<Vertex, VertexAnnouncementState>();
    for ( let i = 0; i < this.circuit.vertexGroup.count; i++ ) {
      const vertex = this.circuit.vertexGroup.getElement( i );
      map.set( vertex, this.createVertexAnnouncementState( vertex ) );
    }
    return map;
  }

  private getLightBulbAnnouncementState( lightBulb: LightBulb ): LightBulbAnnouncementState {
    const brightness = this.computeLightBulbBrightness( lightBulb );
    if ( brightness <= LIGHT_BULB_OFF_THRESHOLD ) {
      return 'off';
    }
    if ( brightness <= LIGHT_BULB_DIM_THRESHOLD ) {
      return 'dim';
    }
    if ( brightness <= LIGHT_BULB_STEADY_THRESHOLD ) {
      return 'steady';
    }
    return 'bright';
  }

  private computeLightBulbBrightness( lightBulb: LightBulb ): number {
    const current = lightBulb.currentProperty.value;
    const resistance = lightBulb.resistanceProperty.value;
    const power = Math.abs( current * current * resistance );
    const numerator = Math.log( 1 + power * LIGHT_BULB_BRIGHTNESS_MULTIPLIER );
    const denominator = Math.log( 1 + LIGHT_BULB_MAXIMUM_POWER * LIGHT_BULB_BRIGHTNESS_MULTIPLIER );
    return Utils.clamp( denominator === 0 ? 0 : numerator / denominator, 0, 1 );
  }

  private processPendingContextAnnouncements(): void {
    if ( !this.circuitElementAnnouncementStates && !this.vertexAnnouncementStates && this.pendingContextEvents.length === 0 ) {
      return;
    }

    const sentences: string[] = [];
    const currentElementStates = this.circuitElementAnnouncementStates ? this.collectCircuitElementAnnouncementStates() : null;

    this.pendingContextEvents.forEach( event => {
      if ( event.type === 'vertices-joined' ) {
        const connectedElements = this.getConnectedElementTypeDescriptions( event.vertex );
        if ( connectedElements.length > 0 ) {
          sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.connectedElements.format( {
            elements: connectedElements.join( ', ' )
          } ) );
        }
      }
      else if ( event.type === 'vertex-split' ) {
        sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.vertexSplit.format( {
          vertexName: event.vertexLabel,
          connectionCount: event.createdVertexCount
        } ) );
      }
      else {
        sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.elementRemoved.format( {
          elementName: event.elementName
        } ) );
      }
    } );

    if ( this.circuitElementAnnouncementStates && currentElementStates ) {
      this.circuitElementAnnouncementStates.forEach( ( previousState, circuitElement ) => {
        const currentState = currentElementStates.get( circuitElement );
        if ( !currentState ) {
          return;
        }

        if ( previousState.brightnessState && currentState.brightnessState &&
             previousState.brightnessState !== currentState.brightnessState ) {
          sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.lightBulbState.format( {
            elementName: this.getElementDisplayName( circuitElement ),
            state: currentState.brightnessState
          } ) );
        }

        if ( previousState.resistance !== null && currentState.resistance !== null &&
             !this.areValuesClose( previousState.resistance, currentState.resistance ) ) {
          const type = circuitElement instanceof LightBulb ? 'lightBulb' : 'resistor';
          sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.componentValueChange.format( {
            elementName: this.getElementDisplayName( circuitElement ),
            type: type,
            oldValue: this.formatValue( previousState.resistance, this.getDisplayDecimalPlaces( circuitElement ) ),
            newValue: this.formatValue( currentState.resistance, this.getDisplayDecimalPlaces( circuitElement ) )
          } ) );
        }

        if ( previousState.voltage !== null && currentState.voltage !== null &&
             !this.areValuesClose( previousState.voltage, currentState.voltage ) ) {
          sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.componentValueChange.format( {
            elementName: this.getElementDisplayName( circuitElement ),
            type: 'battery',
            oldValue: this.formatValue( previousState.voltage, this.getDisplayDecimalPlaces( circuitElement ) ),
            newValue: this.formatValue( currentState.voltage, this.getDisplayDecimalPlaces( circuitElement ) )
          } ) );
        }
      } );
    }

    const previousCurrentMagnitudes = this.circuitElementAnnouncementStates ?
                                      Array.from( this.circuitElementAnnouncementStates.values() ).map( state => state.currentMagnitude ) :
      [];
    const currentCurrentMagnitudes = currentElementStates ?
                                     Array.from( currentElementStates.values() ).map( state => state.currentMagnitude ) :
      [];
    this.appendCurrentFlowSentence( previousCurrentMagnitudes, currentCurrentMagnitudes, sentences );

    if ( sentences.length > 0 ) {
      this.contextAnnouncementEmitter.emit( sentences.join( ' ' ) );
    }

    this.clearPendingContextAnnouncements();
  }

  private clearPendingContextAnnouncements(): void {
    this.circuitElementAnnouncementStates = null;
    this.vertexAnnouncementStates = null;
    this.pendingContextEvents.length = 0;
  }

  private getConnectedElementTypeDescriptions( vertex: Vertex ): string[] {
    const connectedElements = this.circuit.getNeighborCircuitElements( vertex );
    const seen = new Set<string>();
    const descriptions: string[] = [];
    connectedElements.forEach( element => {
      const label = this.getElementTypeLabel( element );
      if ( !seen.has( label ) ) {
        seen.add( label );
        descriptions.push( label );
      }
    } );
    return descriptions;
  }

  private getElementDisplayName( circuitElement: CircuitElement ): string {
    const label = circuitElement.labelStringProperty.value.trim();
    if ( label.length > 0 ) {
      return label;
    }
    const stringProperty = _.get( CircuitConstructionKitCommonStrings, `${circuitElement.type}StringProperty` );
    return stringProperty ? stringProperty.value : circuitElement.type;
  }

  private getElementTypeLabel( circuitElement: CircuitElement ): string {
    const stringProperty = _.get( CircuitConstructionKitCommonStrings, `${circuitElement.type}StringProperty` );
    const label = stringProperty ? stringProperty.value : circuitElement.type;
    return label.toLowerCase();
  }

  private getVertexLabel( vertex: Vertex ): string {
    const label = vertex.labelStringProperty.value.trim();
    if ( label.length > 0 ) {
      return label;
    }
    return CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.vertexDefaultLabel.format( {
      index: vertex.index + 1
    } );
  }

  private formatValue( value: number, decimalPlaces: number ): string {
    return Utils.toFixed( value, decimalPlaces );
  }

  private formatCurrent( magnitude: number ): string {
    return Utils.toFixed( magnitude, 2 );
  }

  private areValuesClose( a: number, b: number ): boolean {
    return Math.abs( a - b ) < 1E-6;
  }

  private getDisplayDecimalPlaces( circuitElement: CircuitElement ): number {
    return circuitElement instanceof FixedCircuitElement ? circuitElement.numberOfDecimalPlaces : 2;
  }

  private getUniqueCurrentMagnitudes( magnitudes: number[] ): number[] {
    const sorted = magnitudes.slice().sort( ( a, b ) => a - b );
    const unique: number[] = [];
    sorted.forEach( value => {
      const isDuplicate = unique.some( existing => Math.abs( existing - value ) < CURRENT_EQUALITY_TOLERANCE );
      if ( !isDuplicate ) {
        unique.push( value );
      }
    } );
    return unique;
  }

  private haveCurrentMagnitudesChanged( previous: number[], current: number[] ): boolean {
    if ( previous.length !== current.length ) {
      return true;
    }
    const sortedPrevious = previous.slice().sort( ( a, b ) => a - b );
    const sortedCurrent = current.slice().sort( ( a, b ) => a - b );
    for ( let i = 0; i < sortedPrevious.length; i++ ) {
      if ( Math.abs( sortedPrevious[ i ] - sortedCurrent[ i ] ) > CURRENT_EQUALITY_TOLERANCE ) {
        return true;
      }
    }
    return false;
  }

  private appendCurrentFlowSentence( previousMagnitudes: number[], currentMagnitudes: number[], sentences: string[] ): void {
    const previousFlowing = previousMagnitudes.filter( magnitude => magnitude > CURRENT_PRESENT_THRESHOLD );
    const currentFlowing = currentMagnitudes.filter( magnitude => magnitude > CURRENT_PRESENT_THRESHOLD );
    const hadFlowBefore = previousFlowing.length > 0;
    const hasFlowNow = currentFlowing.length > 0;

    if ( hasFlowNow ) {
      const flowsChanged = !hadFlowBefore || this.haveCurrentMagnitudesChanged( previousFlowing, currentFlowing );
      if ( flowsChanged ) {
        const uniqueCurrents = this.getUniqueCurrentMagnitudes( currentFlowing );
        if ( uniqueCurrents.length <= 1 ) {
          const magnitude = uniqueCurrents.length === 1 ? uniqueCurrents[ 0 ] : currentFlowing[ 0 ];
          sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.currentChangedSingle.format( {
            current: this.formatCurrent( magnitude )
          } ) );
        }
        else {
          sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.currentMultipleStringProperty.value );
        }
      }
    }
    else if ( hadFlowBefore ) {
      sentences.push( CircuitConstructionKitCommonFluent.a11y.circuitContextResponses.currentStoppedStringProperty.value );
    }
  }
}

circuitConstructionKitCommon.register( 'CircuitContextStateTracker', CircuitContextStateTracker );
